**목차**

1. [상속](#상속)
2. [부모 생성자 호출](#부모-생성자-호출)
3. [메소드 재정의](#메소드-재정의)
4. [final 클래스와 메소드](#final-클래스와-메소드)
5. [Protected](#protected)
6. [타입 변환](#타입-변환)
7. [다형성](#다형성)
8. [추상 클래스](#추상-클래스)

---

### 상속

**부모가 자식에게 물려주는 행위**

```java
public class A {
    int field1;
    void method1() { ... }
}

// 상속받기
public class B extends A {
    String field2;
    void method2() { ... }
}
```

* 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄여 개발 시간 단축
  * field1 과 method1 을 부모 클래스 (A) 에서 상속 받고 field2 와 method2 만 추가 작성
* 클래스의 수정 최소화
  * 부모 클래스를 수정하면 모든 자식 클래스에 수정 효과 가져온다



**클래스 상속**

```java
public class 자식 클래스 extends 부모 클래스 {
}
```

* 다중 상속을 허용하지 않기 때문에 extends 뒤에는 단 하나의 부모 클래스만 와야 한다

---

### 부모 생성자 호출

**모든 객체는 생성자를 호출해야 생성되므로 부모 객체도 예외는 아님**

* 부모 생성자는 자식 생성자의 맨 첫 줄에 숨겨져 있는 super() 에 의해 호출된다

  ```java
  // 자식 생성자 선언
  public 자식클래스(...) {
      super()
  }
  ```

  * super() 은 컴파일 과정에서 자동 추가되며 이는 부모의 기본 생성자를 호출하는 기능
    * 부모 클래스에 기본 생성자가 있어야 한다
    * 부모 클래스에 매개변수를 갖는 생성자만 있다면
      * super(매개값, ...) 처럼 매개값을 넣어줘야 한다

---

### 메소드 재정의

**부모의 어떤 메소드는 자식 클래스가 사용하기에 부적합, 이런 메소드를 자식 클래스에서 재정의해서 사용하는 것**

&rarr; **메소드 오버라이딩**

* 주의점
  * 부모 메소드의 선언부 (리턴 타입, 메소드 이름, 매개변수) 와 동일해야 한다
  * 접근 제한을 더 강하게 오버라이딩 할 수 없다 (public &rarr; private 로 변경 불가)
  * 새로운 예외를 throws 할 수 없다
* `@Override` 어노테이션
  * 컴파일 단계에서 정확히 오버라이딩이 되었는지 체크, 안됐으면 컴파일 에러



**부모 메소드 호출**

* 메소드를 재정의하면 부모 메소드는 숨겨지고 자식 메소드만 사용 된다

  * 따라서 부모 메소드의 일부를 사용하기 위해선 중복된 내용을 자식 메소드도 가지고 있어야 한다

  * 이를 해결하기 위한 방식이 공동 작업 처리 기법

    * 자식 메소드 내에서 부모 메소드를 호출하는 것

    ```java
    class Parent {
        public void method() {
            // 작업처리 1
        }
    }
    
    // 상속
    class Child extends Parent {
        @Override
        super.method(); // 위치는 작업처리 2 전후에 어디든 올 수 있다
        // 작업처리 2
    }
    ```

    * super 키워드와 도트 `.` 연산자를 이용해 숨겨진 부모 메소드 호출

---

### final 클래스와 메소드

**final 클래스**

* 더 이상 상속할 수 없는 클래스이므로 final 클래스는 부모 클래스가 될 수 없어 자식 클래스 생성 불가능

  &rarr; String 클래스가 대표적인 예시

**final 메소드**

* 최종적인 메소드이므로 오버라이딩할 수 없는 메소드

---

### Protected 

**상속과 관련이 있고 public 과 default 중간 쯤에 해당하는 접근 제한**

| 접근 제한자 | 제한 대상            | 제한 범위                             |
| ----------- | -------------------- | ------------------------------------- |
| protected   | 필드, 생성자, 메소드 | 같은 패키지거나 자식 객체만 사용 가능 |

---

### 타입 변환

**클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 발생**

**자동 타입 변환**

```
부모타입 변수 = 자식타입 객체;
```

* 예시로, 고양이가 동물의 특징과 기능을 상속 받았다면 `고양이는 동물이다` 가 성립한다

  * 그래서 Cat 객체를 생성하고 이것을 Animal 변수에 대입하면 자동 타입 변환이 일어난다

  ```java
  Cat cat = new Cat();
  Animal animal = cat;
  
  // 두 참조 변수의 연산 결과는 true 가 나온다
  cat == animal // true
  ```

* 바로 위의 부모가 아니더라도 상속 계층에서 상위 타입이면 자동 타입 변환이 일어날 수 있다
* 부모 타입으로 자동 변환 타입 이후
  * 부모 클래스에 선언된 필드와 메소드만 접근 가능
  * 변수로 접근 가능한 멤버는 부모 클래스 멤버로 한정
  * 그러나 메소드의 경우, 자식 클래스에서 오버라이딩 된 메소드가 부모 메소드 대신 호출된다 (다형성)



**강제 타입 변환**

* 부모 타입은 자식 타입으로 자동 변환되지 않고 캐스팅 연산자로 강제 타입 변환 가능

  ```
  자식타입 변수 = (자식타입) 부모타입객체;
  ```

  * 무조건 강제 변환할 수 있는 것은 아니다

    * 자식 객체가 부모 타입으로 자동 변환된 후 다시 자식 타입으로 변경할 때 강제 타입 변환 가능

    ```java
    Parent parent = new Child(); // 자동 타입 변환
    Child child = (Child) parent; // 강제 타입 변환
    ```



**객체 타입 확인**

**변수가 참조하는 객체의 타입을 확인하거나 매개변수의 다형성에서 실제로 어떤 객체가 매개값으로 제공됐는지 확인할 때, `instanceof` 연산자 사용**

```java
boolean result = 객체 instanceof 타입;
```

* 좌항의 객체가 우항의 타입이면 true, 아니면 false

---

### 다형성

**사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질**

* 다형성 구현을 위해선 자동 타입 변환과 메소드 재정의 필요

  

**필드 다형성**

* 필드 타입은 동일하지만 대입되는 객체가 달라져서 실행 결과가 다양하게 나오는 것

  ```java
  public class Car {
      // 필드 선언
      public Tire tire;
      
      // 메소드 선언
      public void run() {
          tire.roll();
      }
  }
  ```

  * 다음과 같이 객체를 Tire 필드에 대입 가능 
    * 자동 타입 변환이 되기 때문

  ```java
  // Car 객체 생성
  Car myCar = new Car();
  
  // HankookTire 장착
  myCar.tire = new HankookTire();
  
  // KumhoTire 장착
  myCar.tire = new KumhoTire();
  ```

  ```java
  // 대입된 타이어의 roll() 메소드 호출
  myCar.run()
  ```

  * 여기서 어떤 타이어를 장착했느냐에 따라 실행 결과가 달라지게 된다
    * 메소드 재정의가 이뤄지게 된다면



**매개변수 다형성**

**메소드가 클래스 타입의 매개변수를 가지고 있을 때, 호출 시 동일한 타입의 객체를 제공하는 것이 정석**

&rarr; **하지만 자식 객체를 제공할 수도 있고, 여기서 다형성 발생**

---

### 추상 클래스

**객체를 생성할 수 있는 실체 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스를 추상 클래스라고 한다**

* 실체 클래스의 부모 역할
  * 실체 클래스는 추상 클래스를 상속해서 공통적인 필드나 메소드를 물려받기 가능

* new 연산자를 사용해서 객체를 직접 생성할 수 없다
* 추상 클래스는 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용 된다
  * extends 뒤에만 오는 것이 가능



**선언**

```java
public abstract class 클래스명 {
    // 필드
    // 생성자
    // 메소드
}
```

* 자식 객체가 생성될 때 super() 로 추상 클래스의 생성자 호출, 생성자도 반드시 있어야 한다



**추상 메소드와 재정의**

* 선언

  ```java
  abstract 리턴타입 메소드명(매개변수, ... )
  ```

* 추상 메소드는 자식 클래스의 공통 메소드라는 것만 정의

  * 실행 내용을 가지지 않는다

    ```java
    public abstract class Animal {
        abstract void sound()
    }
    ```

* 추상 메소드는 자식 클래스에서 반드시 재정의 (오버라이딩) 해서 실행 내용을 채워야 한다

---

### 봉인된 클래스

```java
public sealed class Person permits Employee, Manager { ... }
```

* Person 의 자식 클래스는 Employee 와 Manager 만 가능

* Employee 와 Manager 은 final 또는 non-sealed 키워드로 다음과 같이 선언하거나 sealed 키워드를 사용해 봉인 클래스로 선언

  ```java
  public final class Employee extends Person { ... }
  
  // 봉인 해제이므로 자식 클래스를 만들 수 있다
  public non-sealed class Manager extends Person { ... } 
  ```

  