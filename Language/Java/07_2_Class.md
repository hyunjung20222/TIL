**목차**

1. [인스턴스 멤버](#인스턴스-멤버)
2. [final 필드와 상수](#fianl-필드와-상수)
3. [접근 제한자](#접근-제한자)
4. [Getter 와 Setter](#getter-와-setter)
5. [싱글톤 패턴](#싱글톤-패턴)

---

### 인스턴스 멤버

**인스턴스 멤버**

* 객체에 소속된 멤버 (객체가 있어야만 사용 가능)

**정적 멤버**

* 메소드 영역의 클래스에 고정적으로 위치하는 멤버

* 객체 생성 필요 없이 클래스를 통해 바로 사용 가능

  ```java
  public class 클래스 {
      // 정적 필드 선언
      static 타입 필드 [= 초기값];
      
      // 정적 메소드
      static 리턴타입 메소드(매개변수, ...) { ... }
  }
  ```

  * 객체마다 가지고 있을 필요성이 없는 공용 필드는 정적 필드로 선언
    * eg. 원의 넓이나 둘레를 구할 때 필요한 파이값

* 클래스 이름과 함께 도트 `.` 연산자로 접근 가능

**정적 블록**

* 정적 필드는 필드 선언과 동시에 초기값을 준다

  * 복잡한 초기화 작업이 필요하다면 정적 블록을 이용

    ```java
    static {
        ...
    }
    ```

    

* 정적 블록이 클래스 내부에 여러 개 선언돼있을 때 선언된 순서대로 실행
* **정적 메소드와 정적 블록은 인스턴스 멤버를 사용할 수 없고, this 도 사용할 수 없다**

---

### final 필드와 상수

**final 필드**

* 초기값이 저장되면 이 것이 최종적인 값이 돼 프로그램 실행 도중에 수정 불가능

  ```
  final 타입 필드 [= 초기값];
  ```

* **필드 선언 시에 초기값 대입**

* **생성자에서 초기값 대입**

  &rarr; final 필드에 초기값을 줄 수 있는 두 가지 방법



**상수 선언**

* 객체마다 저장할 필요가 없고 여러 개의 값을 가질 필요도 없기 때문에 static 이면서 final 특성을 지니고 있음

  ```
  static final 타입 상수 [= 초기값];
  ```

* 복잡한 초기화가 필요할 경우 정적 블록에서 초기화할 수도 있다

* 상수 이름은 모두 대문자

  * 다른 단어가 혼합된 경우, 언더바 `_` 로 단어들을 연결

* 클래스로 접근해서 읽을 수 있다

---

### 패키지

**패키지는 클래스의 일부분이며, 클래스를 식별하는 용도로 사용**

* 주로 도메인 이름의 역순으로 만든다

* `com.mycompany` 

  ```
  com
   |--- mycompany
   |       |------- Car.class
   |
   |--- yourcompany
   |        |------ Car.class
  ```

* 상위 패키지와 하위 패키지를 도트 `.` 로 구분

  * com 은 상위 패키지, mycompany 가 하위 패키지

* 패키지는 클래스를 식별하는 용도로 사용

  * 클래스의 전체 이름에 포함 (com.mycompany.Car 클래스)



**패키지 선언**

* 클래스를 컴파일하는 과정에서 패키지 디렉토리 자동 생성
  * 패키지 선언은 package 키워드와 함께 패키지 이름을 기술한 것
    * 항상 소스 파일 최상단에 위치해야 한다

* 패키지 이름은 모두 소문자

  * 패키지 이름이 중복되지 않도록 회사 도메인 이름의 역순으로 정하기

  * 마지막에는 프로젝트 이름을 붙이는 것이 일반적

    ```
    com.samsung.projectname
    com.lg.projectname
    ```



**import 문**

* 다른 패키지에 있는 클래스를 사용하려면 import 문을 이용해서 어떤 패키지의 클래스를 사용하는지 명시

  ```java
  package com.mycompany
  
  import com.hankook.Tire // Tire 클래스의 전체 이름
  ```

* import 문 작성 위치는 패키지 선언과 클래스 선언 사이

  * import 키워드 뒤에는 사용하고자 하는 클래스의 전체 이름 기술
  * 다수의 클래스 이용 시 클래스 이름 생략 후 `*` 사용 가능

* import 문은 하위 패키지를 포함하지 않는다

  * 서로 다른 패키지에 동일한 클래스 이름이 존재할 때
    * 두 패키지를 모두 import 하고 같은 클래스 이름의 클래스를 사용할 경우 컴파일 에러
    * 이 경우, 클래스 전체 이름을 사용해 정확한 패키지 클래스를 사용하는 지 알려야 한다
      * 이 경우 import 문은 필요 없다

---

### 접근 제한자

* 객체의 필드를 외부에서 변경하거나 메소드를 호출할 수 없도록 막아야 할 필요성
  * 중요한 필드와 메소드의 외부 노출을 막아 객체의 무결성을 유지하기 위해

* 이를 위해 접근 제한자 사용

| 접근 제한자 | 제한 대상                    | 제한 범위                             |
| ----------- | ---------------------------- | ------------------------------------- |
| public      | 클래스, 필드, 생성자, 메소드 | 없음                                  |
| protected   | 필드, 생성자, 메소드         | 같은 패키지거나 자식 객체만 사용 가능 |
| default     | 클래스, 필드, 생성자, 메소드 | 같은 패키지                           |
| private     | 필드, 생성자, 메소드         | 객체 내부                             |

**클래스**

* public 과 default 접근 제한을 가질 수 있다
  * 접근 제한자를 생략한다면 클래스는 default 접근 제한을 가진다
    * 이 경우, 같은 패키지 내에서는 아무런 제한이 없지만 다른 패키지에서는 사용할 수 없다
  * public 의 경우 다른 패키지에서도 사용할 수 있다



**생성자**

* public, default 와 private 접근 제한을 가질 수 있다

  | 접근 제한자 | 설명                                                         |
  | ----------- | ------------------------------------------------------------ |
  | public      | 모든 패키지에서 생성자를 호출할 수 있다<br />= 모든 패키지에서 객체를 생성할 수 있다 |
  | default     | 같은 패키지에서만 생성자를 호출할 수 있다<br />= 같은 패키지에서만 객체를 생성할 수 있다 |
  | private     | 클래스 내부에서만 생성자를 호출할 수 있다<br />= 클래스 내부에서만 객체를 생성할 수 있다 |



**필드와 메소드**

| 접근 제한자 | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| public      | 모든 패키지에서 필드를 읽고 변경할 수 있다<br />모든 패키지에서 메소드를 호출할 수 있다 |
| default     | 같은 패키지에서만 필드를 읽고 변경할 수 있다<br />같은 패키지에서만 메소드를 호출할 수 있다 |
| private     | 클래스 내부에서만 필드를 읽고 변경할 수 있다<br />클래스 내부에서만 메소드를 호출할 수 있다 |

---

### Getter 와 Setter

* 객체의 필드를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨지는 문제

  * 직접적인 외부에서의 필드 접근을 막고 메소드를 통해 필드에 접근하도록

  * 메소드는 데이터를 검증해서 유효한 값만 필드에 저장할 수 있기 때문에

    * 이 역할을 하는 것이 **Setter**

    ```java
    private double speed;
    
    public void setSpeed(double speed) {
        if(speed < 0) {
            this.speed = 0; // 매개값이 음수일 경우 speed 필드에 0으로 저장하고 메소드 실행 종료
            return;
        } else {
            this.speed = speed;
        }
    }
    ```

* 외부에서 객체의 필드를 읽을 때 필요한 메소드

  * 필드값이 객체 외부에서 사용하기 부적절할 때, 메소드로 적절한 값으로 변환해 리턴 가능

    * 이 역할을 하는 것이 **Getter**

    ```java
    private double speed;
    
    public double getSpeed() {
        double km = speed * 1.6;
        return km; // 필드값인 mile 을 km 단위로 환산 후 외부로 리턴
    }
    ```

  * 필드 타입이 boolean 일 경우 Getter 는 get 으로 시작되지 않고 is 로 시작하는 것이 관례

---

### 싱글톤 패턴

**어플리케이션 전체에서 단 한 개의 객체만 생성해서 사용하고 싶을 때 적용 가능**

* 생성자를 private 접근 제한해서 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는 것

  * 외부에서 마음대로 객체 생성하는 것이 불가능
  * 싱글톤 패턴이 제공하는 정적 메소드를 통해 간접적 객체 얻기 가능

  ```java
  public class 클래스 {
      // private 접근 권한을 갖는 정적 필드 선언과 초기화
      private static 클래스 singleton = new 클래스();
      
      // private 접근 권한을 갖는 생성자 선언
      private 클래스() {}
      
      // public 접근 권한을 갖는 정적 메소드 선언
      public static 클래스 getInstance() {
          return singleton;
      }
  }
  ```

  * 위 코드의 경우, 외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드 호출
    * getInstance() 메소드가 리턴하는 객체는 정적 필드가 참조하는 싱글톤 객체